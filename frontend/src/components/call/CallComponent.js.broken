import React, { useEffect, useState } from 'react';
import { Platform, PermissionsAndroid, View, Text, StyleSheet } from 'react-native';

// Detect if we're running on web
const isWeb = Platform.OS === 'web';

// Detect if we're running on web
const isWeb = Platform.OS === 'web';

// Logging function
const log = (message, type = 'info') => {
  const timestamp = new Date().toISOString();
  const logPrefix = `[VOICE-CALL][${timestamp}]`;
  
  switch(type) {
    case 'error':
      console.error(`${logPrefix} ERROR:`, message);
      break;
    case 'warning':
      console.warn(`${logPrefix} WARNING:`, message);
      break;
    case 'success':
      console.log(`${logPrefix} SUCCESS:`, message);
      break;
    default:
      console.log(`${logPrefix} INFO:`, message);
  }
};

const APP_ID = '81e82eacfa0f4fdd8ef607513d9a7269';
const CHANNEL_NAME = 'test';
const UID = Math.floor(Math.random() * 100000);
const TOKEN_URL = `http://localhost:8000/generate_token?channel_name=${CHANNEL_NAME}&uid=${UID}`;

log(`Initializing VoiceCall component with UID: ${UID}, Channel: ${CHANNEL_NAME}`);

const VoiceCall = () => {
  const [joined, setJoined] = useState(false);
  const [token, setToken] = useState('');
  const [logs, setLogs] = useState([]);
  const [error, setError] = useState(null);

  // Add log to state for UI display
  const addLog = (message, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    setLogs(prevLogs => [...prevLogs, { message, type, timestamp }]);
    log(message, type);
  };

  useEffect(() => {
    addLog('Voice call component mounted');
      const init = async () => {
      try {
        addLog(`Initializing call on platform: ${Platform.OS}`);
        addLog('Requesting token from server...');
        
        try {
          const response = await fetch(TOKEN_URL);
          
          if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (!data.token) {
            throw new Error('No token received from server');
          }
          
          addLog('Token received successfully', 'success');
          setToken(data.token);

          if (isWeb) {
            addLog('Initializing web platform call');
            initWeb(data.token);
          } else {
            addLog('Initializing mobile platform call');
            await requestPermissions();
            initMobile(data.token);
          }
        } catch (fetchError) {
          // If in development mode and token server is not running,
          // provide a mock token for testing
          if (process.env.NODE_ENV === 'development' || __DEV__) {
            addLog('Using mock token for development', 'warning');
            const mockToken = "mockTokenForTesting";
            setToken(mockToken);
            
            if (isWeb) {
              addLog('Initializing web platform call with mock token');
              initWeb(mockToken);
            } else {
              addLog('Initializing mobile platform call with mock token');
              await requestPermissions();
              initMobile(mockToken);
            }
          } else {
            throw fetchError;
          }
      } catch (err) {
        addLog(`Error initializing call: ${err.message}`, 'error');
        setError(err.message);
      }
    };

    init();

    return () => {
      addLog('Cleaning up voice call component');
      leaveChannel();
    };
  }, []);  const initMobile = async (token) => {
    try {
      addLog('Loading RtcEngine for mobile');
      // Import dynamically to avoid bundling issues with web
      let RtcEngine;
      try {
        // Using dynamic import to prevent web bundling issues
        RtcEngine = (await import('react-native-agora')).default;
        addLog('Successfully imported react-native-agora package', 'success');
      } catch (importError) {
        addLog(`Failed to import Agora SDK: ${importError.message}`, 'error');
        setError("Agora SDK not available on this platform");
        return;
      }
      
      addLog('Creating RtcEngine instance');
      const engine = await RtcEngine.create(APP_ID);
      
      addLog('Enabling audio');
      await engine.enableAudio();
      
      addLog('Setting up event listeners');
      engine.addListener('JoinChannelSuccess', (channel, uid, elapsed) => {
        addLog(`Successfully joined channel: ${channel}, with UID: ${uid}`, 'success');
        setJoined(true);
      });
      
      engine.addListener('Error', (error) => {
        addLog(`Agora error: ${error}`, 'error');
      });
      
      engine.addListener('ConnectionStateChanged', (state, reason) => {
        addLog(`Connection state changed to: ${state}, reason: ${reason}`);
      });
      
      addLog(`Joining channel: ${CHANNEL_NAME} with UID: ${UID}`);
      await engine.joinChannel(token, CHANNEL_NAME, null, UID);
      addLog('Join channel command sent');
    } catch (err) {
      addLog(`Error in initMobile: ${err.message}`, 'error');
      setError(err.message);
    }
  };

  const initWeb = async (token) => {
    try {
      addLog('Importing AgoraRTC for web');
      const AgoraRTC = await import('agora-rtc-sdk-ng');
      
      addLog('Creating RTC client');
      const client = AgoraRTC.createClient({ mode: 'rtc', codec: 'vp8' });
      
      addLog('Setting up event listeners for web client');
      client.on('connection-state-change', (currentState, prevState) => {
        addLog(`Connection state changed from ${prevState} to ${currentState}`);
      });
      
      addLog(`Joining channel: ${CHANNEL_NAME} with UID: ${UID}`);
      await client.join(APP_ID, CHANNEL_NAME, token, UID);
      addLog('Successfully joined channel on web', 'success');
      
      addLog('Creating microphone audio track');
      const localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
      
      addLog('Publishing audio track to channel');
      await client.publish([localAudioTrack]);
      addLog('Audio track published successfully', 'success');
      
      setJoined(true);
    } catch (err) {
      addLog(`Error in initWeb: ${err.message}`, 'error');
      setError(err.message);
    }
  };  const leaveChannel = async () => {
    try {
      addLog('Attempting to leave channel');
      
      if (Platform.OS === 'web') {
        addLog('Cleaning up web resources');
        // Implement web cleanup if needed
        addLog('Web cleanup completed');
      } else {
        try {
          addLog('Loading RtcEngine for cleanup');
          // Using dynamic import to prevent web bundling issues
          const RtcEngine = (await import('react-native-agora')).default;
          
          addLog('Creating engine instance for cleanup');
          const engine = await RtcEngine.create(APP_ID);
          
          addLog('Leaving channel');
          await engine.leaveChannel();
          
          addLog('Destroying engine instance');
          engine.destroy();
        } catch (importError) {
          addLog(`Failed to import Agora SDK for cleanup: ${importError.message}`, 'warning');
          // Continue with the cleanup even if the import fails
        }
      }
      
      addLog('Successfully left channel', 'success');
      setJoined(false);
    } catch (err) {
      addLog(`Error leaving channel: ${err.message}`, 'error');
    }
  };

  const requestPermissions = async () => {
    try {
      if (Platform.OS === 'android') {
        addLog('Requesting Android audio permissions');
        
        const granted = await PermissionsAndroid.requestMultiple([
          PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
        ]);
        
        if (granted[PermissionsAndroid.PERMISSIONS.RECORD_AUDIO] === PermissionsAndroid.RESULTS.GRANTED) {
          addLog('Audio recording permission granted', 'success');
          return true;
        } else {
          addLog('Audio recording permission denied', 'error');
          throw new Error('Audio recording permission denied');
        }
      } else if (Platform.OS === 'ios') {
        addLog('iOS permissions handled by the system');
        return true;
      }
    } catch (err) {
      addLog(`Error requesting permissions: ${err.message}`, 'error');
      throw err;
    }
  };
  return (
    <View style={styles.container}>
      <Text style={styles.statusText}>
        {error ? 'Connection Error' : joined ? 'In Call' : 'Joining channel...'}
      </Text>
      
      {error && (
        <Text style={styles.errorText}>
          Error: {error}
        </Text>
      )}
      
      <View style={styles.logContainer}>
        <Text style={styles.logTitle}>Call Activity Log:</Text>
        {logs.map((log, index) => (
          <Text 
            key={index} 
            style={[
              styles.logEntry, 
              log.type === 'error' && styles.logError,
              log.type === 'success' && styles.logSuccess,
              log.type === 'warning' && styles.logWarning
            ]}
          >
            [{log.timestamp}] {log.message}
          </Text>
        ))}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    backgroundColor: '#f8f9fa',
    borderRadius: 10,
    width: '100%',
    maxWidth: 500,
  },
  statusText: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  errorText: {
    fontSize: 16,
    color: '#dc3545',
    marginBottom: 20,
    textAlign: 'center',
  },
  logContainer: {
    marginTop: 20,
    padding: 10,
    backgroundColor: '#343a40',
    borderRadius: 5,
    maxHeight: 300,
    overflow: 'scroll',
  },
  logTitle: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  logEntry: {
    color: '#ced4da',
    fontSize: 12,
    fontFamily: 'monospace',
    marginBottom: 5,
  },
  logError: {
    color: '#ff6b6b',
  },
  logSuccess: {
    color: '#51cf66',
  },
  logWarning: {
    color: '#fcc419',
  }
});

export default VoiceCall;
